[同盟シンボルの衝突]
実行結果：readelf-d_main-shared.txt
C/C++プログラム：
 a.c, b.c, main.c link_objects.txt
 a.c, b.c, link_to_shared.txt
 a.c, b.c, main.c link_archive.txt
 a.c, b.c, main.c link_shared_objects.txt
 
(.oファイルをまとめてリンクする場合)

・同一名の関数を2つのソースファイルで定義している場合、オブジェクトファイルを
リンクする段階でリンクエラーがでる（link_objects.txt）

・同様に、同一名の関数定義を含む2つのオブジェクトファイル（これらは-fPICコンパイル）
を１つの共有オブジェクトにリンクするときもリンクエラーが出る（link_to_shared.txt）

（ライブラリを使ってリンクする場合）

・同一名の関数定義を含む2つのオブジェクトファイルを１つの静的ライブラリにまとめて
mainプログラムとリンクすると、リンク時のエラーは出ない。この場合、静的ライブラリ内で
最初に見つかった定義が拾われる（link_archive.txt）

・同様に、同一名の関数定義を含む2つのオブジェクトファイルから別々の静的ライブラリを
作り、この2つの静的ライブラリをmainプログラムとリンクすると、リンク時のエラーは出ない。
この場合、リンクコマンドにて最初に現れる静的ライブラリから関数の定義が拾われる
（link_arhive.txt）

・同一名の関数定義を含む2つのソースとmainのソースから別々の共有オブジェクトをつくり
（これらは、-fPICでコンパイルする）、これらをリンクすると、リンクのエラーは出ない。
この場合、リンクコマンドにて最初に現れる共有オブジェクトから関数の定義が拾われる
（link_shared_objects.txt）

・本に記載の、./a.so ./b.so ./main.so の順でリンクすると、func関数が見つからない旨の
エラーが出る。未定義シンボルがコマンドラインのライブラリから順次検索されるので、
funcを参照しているmain.soを先頭に置かなければならないためである（正しい並びは、
./main.so ./a.so ./b.so）。

・リンクコマンドの引数からパス指定を取り除くと（main.so a.so b.soのようにする）、
実行時に共有オブジェクトが見つからない旨のエラーが出る。この場合、LD_LIBRARY_PATH
環境変数にカレントディレクトリを指定する必要がある。

・リンクコマンドに共有オブジェクトをパス付きで指定したとき、LD_LIBRARY_PATH環境変数
を設定する必要がないのは、作成された実行可能ファイル（main-shared）の動的セクションの
NEEDEDタイプに、依存する共有ライブラリ名がパス付きで格納されるためである
（readelf-d_main-shared.txt）


[C++と同名クラス]
実行結果：
C++プログラム：
 a.h, a.cpp, main.cpp, tax1.txt
 a.h, a.cpp, b.h, b.cpp, main.cpp, tax2.txt
 
・消費税込みのりんごの値段を表示するプログラム（a.cpp、main.cpp）をビルドし実行する。
結果は、105円となる（tax1.txt）。ここでは、共有オブジェクトファイルのら並び順は、
./a.so ./main.so ではなく、./main.so ./a.so でなければならない
　
・ここで、同名のTaxクラスを実装したb.cppの共有オブジェクト./b.soを、./a.soより前に
リンクコマンドの引数に並べると、Tax::Tax()はb.soから、Tax::tax(int)はa.soから
拾われるという、矛盾した状態となる。
b.cppのTax::Tax()は、データメンバdeduction_rate_に値0.1を設定するが、このメモリ
レイアウトが、a.cppのTaxクラスのデータメンバconsumption_tax_と同じ位置に存在する。
このため、a.cppのTax::tac(int)はconsumption_tax_データメンバを読み出すと0.1となる。
その結果、りんごの値段は10となる

[weakシンボル]
実行結果：nm_demangle__weak.txt
C++プログラム：
　weak_main.cpp, a.cpp, weak_main.txt
　unnamed_namespace_main.cpp, weak_a.cpp, unnamed_namespace.txt
　
・Fooクラスを含むC++プログラムweak_main.cppをビルドし実行する。これは正しく動作する
次に、同名のクラスFooを含む別のC++プログラムweak_a.cppをコンパイルして、weak_main.o
と一緒にリンクして実行すると、期待した出力結果とならない（weak_main.txt）

・weak_main.cppのFoo::Foo(int)はクラス内に定義されているので、inline関数となる。
一方、weak_a.cppのFoo::Foo(int)はクラス定義の外部で定義されているので、inlineではない、
通常の関数となる。inline関数はweakシンボルとなるので、非weakなweak_a.cppの関数が
リンク時に選択されるので、意図しない結果となった

・nmコマンドでシンボルクラスを確認すると、weak_main.oのFoo::Foo(int)はweakで、
weak_a.oのFoo::Foo(int)は非weakであることがわかる（nm_demange__weak.txt）

・mainプログラムが利用しているFooクラスの定義を無名名前空間に収め、Fooクラスが定義した
名前がソースファイルのスコープとなる（つまりシンボルをリンカに出さない）ように変更すれば
（unnamed_namespae_main.cpp）、この問題は解消する（unnamed_namespace.txt）








