[Cの場合]
ソースファイル：
 main-c.c c-good.c c-good.sh c-good.txt

・pthread_mutext_t型の関数内のstatic変数mを構造体として初期化し、
pthread_mutex_lockで排他制御を行う(c-good.txt)。問題なく動作する


[C++の場合]
ソースファイル：
 main-c++.cpp c++-bad1.cpp c++-bad1.sh c++-bad1.txt
 main-c++.cpp c++-bad2.cpp other.cpp c++-bad2.sh c++-bad2.txt
 main-c++.cpp static_mutex.hpp c++-good.cpp other.cpp c++-good.sh 
   c++-good.txt
 c++-bad1.cpp c++-bad1-safe.sh c++-bad1-safe.txt

・良くない方法（１）として、boost::recursive_mutex型の関数内静的変数
mを使用する。mの初期化は最初にneed_to_sync()関数が呼ばれたときに行われるが、
初回判定のためにフラグを用いる。このフラグアクセスが競合状態となる。
g++ 9.3.0ではフラグの競合解決のための-fthreadsafe-staticsオプションを
デフォルトで使用するので、ここでは-fno-threadsafe-staticsオプションを
指定し、動作確認を行う(c++-bad1.txt)
アセンブリ展開形(c++-bad1.s)を調べると、フラグを調べて、セットされて
いなければboost::recursive_mutexのコンストラクタを呼び出し、フラグを
セットしている

# c++-bad1.cpp:8: 	static boost::recursive_mutex m ;
	leaq	_ZGVZ12need_to_syncvE1m(%rip), %rax	#, _ZGVZ12need_to_syncvE1m.0_1
	movzbl	(%rax), %eax	# MEM[(char *)_ZGVZ12need_to_syncvE1m.0_1], _2
	testb	%al, %al	# _2
	jne	.L256	#,
# c++-bad1.cpp:8: 	static boost::recursive_mutex m ;
	leaq	_ZZ12need_to_syncvE1m(%rip), %rdi	#,
.LEHB20:
	call	_ZN5boost15recursive_mutexC1Ev	#
	leaq	_ZGVZ12need_to_syncvE1m(%rip), %rax	#, _ZGVZ12need_to_syncvE1m.1_3
	movb	$1, (%rax)	#, MEM[(char *)_ZGVZ12need_to_syncvE1m.1_3]

・良くない方法（２）では、変数mを関数内の静的変数の代わりにファイル
グローバル（無名namespace内の変数）とする(c++-bad2.txt)
この場合も、他の大域変数が属するクラスのコンストラクタがneed_to_sync()
関数を呼び出すとmの初期化とmの使用(other.cpp)の順番が制御できずに問題
となる

・素敵な方法として、C互換構造体のstatic_mutex構造体を定義し
(static_mutex.hpp)、プログラムのロード時に初期化する方法を採用する
(c++-good.txt)
アセンブリ展開形(c++-good.s)を調べると、データメンバm_の初期値は
以下のようにテーブルとしてバイナリファイルに組み込まれている

_ZN12_GLOBAL__N_11mE:
# m_:
# __data:
# __lock:
	.long	0
# __count:
	.long	0
# __owner:
	.long	0
# __nusers:
	.long	0
# __kind:
	.long	1
# __spins:
	.value	0
# __elision:
	.value	0
# __list:
# __prev:
	.quad	0
# __next:
	.quad	0

・c++-bad1.cppを-fthreadsafe-staticsオプションでコンパイルすると
(c++-bad1-safe.txt)、__cxa_guard_acuire関数呼び出しで関数内静的変数mの
スレッドセーフ性を保証している(c++-bad1-safe.s)


[remarks]
 
1) PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP is GNU extenstion
so need the following directive before inlcude <pthread.h>
	#define _GNU_SOURECE


2) to see compiled code (*.o) 
use objdump -Sr command such as
	$ objdump -Sr needtosync-c.o
where -r option shows symbol references to be relocated

3) to se compiled code (*.o) from c++
use objdump -CSr command such as
	$ objdup -CSr needosync-c++-bat1.o
where -C option makes mangled symbol demangle
 
