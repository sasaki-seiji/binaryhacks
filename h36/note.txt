[Cの場合]
ソースファイル：
 c-header.h main-c.c c-good.c c-good.sh c-good.txt
 c-header.h main-c.c c-bad-dly.c c-bad-dly.sh c-bad-dly.txt
 c-header.h main-c-pri.c c-bad-pri.c c-bad-pri.sh c-bad-pri.txt
シェルスクリプト：
 loopn.sh

・c-good.cプログラムのneed_to_sync()関数は、pthread_mutext_t構想体型の
変数mはプログラムのロード時に初期化されるので、初期化の競合問題は発生しない
(c-good.txt)。
またテストとして、1000個の競合するスレッドが同時期にneed_to_sync()関数を
呼び出すプログラムを100回繰り返し実行したが、もちろん問題なく動作する
これは、loopnn.shスクリプトを ./loopn 100 ./c-good のように使う

・c-bad-dly.cプログラムのneed_to_sync()関数では、以降のC++での問題点を
明らかにするために、この関数が初めて呼び出されたときにpthread_mutex_t
構造体変数mを初期化する方法で実装する。この場合は初期化の競合問題が発生する

void need_to_sync()
{
	static pthread_mutex_t m;
	static int initialized = 0;
	pthread_mutexattr_t mattr;

	if (initialized == 0) {
		delay(NDELAY);
		initialized = 1;
		
		/* initialize mutex at first call of need_to_sync() */
		pthread_mutexattr_init(&mattr);
		pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE_NP);
		pthread_mutex_init(&m, &mattr);
	}

	pthread_mutex_lock(&m) ;
		do_something() ;
	pthread_mutex_unlock(&m) ;
}

静的変数initializedによってneed_to_sync()が初めて呼ばれたか否かを判定する
そして、初めて呼ばれたときはinitialedをセットして、mを初期化する。
ここでは問題の再現性を高くするため、initializedの0判定と1をセットする間に
delay(NDELAY)呼び出しを挿入している。delayは、引数の個数だけ空ループを
回すだけの関数である
1000個のスレッドから同時期にneed_to_sync関数を呼び出すと、2つ以上のスレッド
が do_something()関数を呼び出してしまう、つまり、排他制御がうまく働いて
いないことがわかる（c-bad-dly.sh）。この実験は、x86_64プロセッサ上の
vmware（8ハードスレッドを割り当てている）で行った

・ディレイを挿入すれば問題を再現できるのであれば、ディレイを外しても
問題が発生する可能性は0ではない。

[C++の場合]
ソースファイル：
 main-c++.cpp c++-bad1.cpp c++-bad1.sh c++-bad1.txt
 main-c++.cpp c++-bad2.cpp other.cpp c++-bad2.sh c++-bad2.txt
 main-c++.cpp static_mutex.hpp c++-good.cpp other.cpp c++-good.sh 
   c++-good.txt
 c++-bad1.cpp c++-bad1-safe.sh c++-bad1-safe.txt

・良くない方法（１）として、boost::recursive_mutex型の関数内静的変数
mを使用する。mの初期化は最初にneed_to_sync()関数が呼ばれたときに行われるが、
初回判定のためにフラグを用いる。このフラグアクセスが競合状態となる。
g++ 9.3.0ではフラグの競合解決のための-fthreadsafe-staticsオプションを
デフォルトで使用するので、ここでは-fno-threadsafe-staticsオプションを
指定し、動作確認を行う(c++-bad1.txt)
アセンブリ展開形(c++-bad1.s)を調べると、フラグを調べて、セットされて
いなければboost::recursive_mutexのコンストラクタを呼び出し、フラグを
セットしている

# c++-bad1.cpp:8: 	static boost::recursive_mutex m ;
	leaq	_ZGVZ12need_to_syncvE1m(%rip), %rax	#, _ZGVZ12need_to_syncvE1m.0_1
	movzbl	(%rax), %eax	# MEM[(char *)_ZGVZ12need_to_syncvE1m.0_1], _2
	testb	%al, %al	# _2
	jne	.L256	#,
# c++-bad1.cpp:8: 	static boost::recursive_mutex m ;
	leaq	_ZZ12need_to_syncvE1m(%rip), %rdi	#,
.LEHB20:
	call	_ZN5boost15recursive_mutexC1Ev	#
	leaq	_ZGVZ12need_to_syncvE1m(%rip), %rax	#, _ZGVZ12need_to_syncvE1m.1_3
	movb	$1, (%rax)	#, MEM[(char *)_ZGVZ12need_to_syncvE1m.1_3]

・良くない方法（２）では、変数mを関数内の静的変数の代わりにファイル
グローバル（無名namespace内の変数）とする(c++-bad2.txt)
この場合も、他の大域変数が属するクラスのコンストラクタがneed_to_sync()
関数を呼び出すとmの初期化とmの使用(other.cpp)の順番が制御できずに問題
となる

・素敵な方法として、C互換構造体のstatic_mutex構造体を定義し
(static_mutex.hpp)、プログラムのロード時に初期化する方法を採用する
(c++-good.txt)
アセンブリ展開形(c++-good.s)を調べると、データメンバm_の初期値は
以下のようにテーブルとしてバイナリファイルに組み込まれている

_ZN12_GLOBAL__N_11mE:
# m_:
# __data:
# __lock:
	.long	0
# __count:
	.long	0
# __owner:
	.long	0
# __nusers:
	.long	0
# __kind:
	.long	1
# __spins:
	.value	0
# __elision:
	.value	0
# __list:
# __prev:
	.quad	0
# __next:
	.quad	0

・c++-bad1.cppを-fthreadsafe-staticsオプションでコンパイルすると
(c++-bad1-safe.txt)、__cxa_guard_acuire関数呼び出しで関数内静的変数mの
スレッドセーフ性を保証している(c++-bad1-safe.s)


[remarks]
 
1) PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP is GNU extenstion
so need the following directive before inlcude <pthread.h>
	#define _GNU_SOURECE


2) to see compiled code (*.o) 
use objdump -Sr command such as
	$ objdump -Sr needtosync-c.o
where -r option shows symbol references to be relocated

3) to se compiled code (*.o) from c++
use objdump -CSr command such as
	$ objdup -CSr needosync-c++-bat1.o
where -C option makes mangled symbol demangle
 
